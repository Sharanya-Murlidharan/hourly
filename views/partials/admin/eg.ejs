const User = require("../../models/userSchema");
const Product = require("../../models/productSchema");
const Cart = require("../../models/cartSchema");
const Address = require("../../models/addressSchema");
const Order = require("../../models/orderSchema");
const Wallet = require("../../models/walletSchema");
const mongoose = require("mongoose");

const getOBjofId = (id) => {
  return new mongoose.Types.ObjectId(id);
};

// Other existing functions (getCheckout, proceedCheckout, etc.) remain unchanged

const getOrderList = async (req, res) => {
  try {
    const userId = req.session.user;
    if (!userId) {
      return res.redirect("/login");
    }

    const page = parseInt(req.query.page) || 1;
    const limit = 5;
    const skip = (page - 1) * limit;

    const user = await User.findById(userId);
    const totalOrders = await Order.countDocuments({ _id: { $in: user.orderHistory } });
    const totalPages = Math.ceil(totalOrders / limit);

    const orders = await Order.find({ _id: { $in: user.orderHistory } })
      .populate("orderedItems.product")
      .sort({ createdOn: -1 })
      .skip(skip)
      .limit(limit);

    const formattedOrders = orders.map(order => {
      return {
        orderId: order.orderId,
        orderDate: order.createdOn.toLocaleDateString('en-GB'),
        status: order.status,
        paymentMethod: order.paymentMethod,
        totalAmount: order.finalAmount,
        items: order.orderedItems.map(item => ({
          productName: item.product ? item.product.productName : 'Unknown Product',
          productImage: item.product && item.product.productImage && item.product.productImage.length > 0
            ? `/${item.product.productImage[0]}`
            : '/images/placeholder.jpg',
          quantity: item.quantity,
          price: item.price,
          subtotal: item.quantity * item.price
        }))
      };
    });

    res.render("orderListing", {
      user,
      orders: formattedOrders,
      currentPage: page,
      totalPages: totalPages
    });
  } catch (error) {
    console.error("Error in getOrderList:", error.message, error.stack);
    res.redirect("/pageNotFound");
  }
};

const orderDetail = async (req, res) => {
  try {
    const userId = req.session.user;
    if (!userId) {
      return res.redirect("/login");
    }
    const orderId = req.params.id;
    const user = await User.findById(userId);
    const order = await Order.findOne({ orderId, _id: { $in: user.orderHistory } })
      .populate("orderedItems.product");
    if (!order) {
      return res.redirect("/pageNotFound");
    }
    res.render("orderDetail", {
      user,
      order
    });
  } catch (error) {
    console.error("Error from orderDetail:", error);
    res.redirect("/pageNotFound");
  }
};

const cancelOrder = async (req, res) => {
  try {
    const userId = req.session.user;
    if (!userId) {
      return res.status(401).json({ success: false, message: 'Unauthorized: Please log in.' });
    }

    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ success: false, message: 'Invalid order ID.' });
    }

    const user = await User.findById(userId);
    const order = await Order.findOne({ _id: id }).populate('orderedItems.product');
    if (!order || !user.orderHistory.includes(order._id)) {
      return res.status(404).json({ success: false, message: 'Order not found or unauthorized.' });
    }

    if (order.status.toLowerCase() === 'canceled' || order.status.toLowerCase() === 'delivered') {
      return res.status(400).json({ success: false, message: 'Order cannot be canceled.' });
    }

    // Restore stock
    for (const item of order.orderedItems) {
      const product = await Product.findById(item.product);
      if (product) {
        product.quantity += item.quantity;
        await product.save();
      }
    }

    // Refund to wallet if payment was made
    if (order.finalAmount > 0 && order.paymentMethod !== 'COD') {
      const wallet = await Wallet.findOneAndUpdate(
        { userId },
        {
          $inc: { balance: order.finalAmount },
          $push: {
            transactions: {
              amount: order.finalAmount,
              type: 'credit',
              description: `Refund for cancelled order ${order.orderId}`,
              date: new Date()
            }
          }
        },
        { upsert: true, new: true }
      );
    }

    order.status = 'Canceled';
    order.totalPrice = 0;
    order.finalAmount = 0;
    order.discount = 0;
    await order.save();

    res.status(200).json({ success: true, message: 'Order canceled successfully.' });
  } catch (error) {
    console.error('Error canceling order:', error.message, error.stack);
    res.status(500).json({ success: false, message: `Server error: ${error.message}` });
  }
};

const cancelProduct = async (req, res) => {
  try {
    const userId = req.session.user;
    if (!userId) {
      return res.status(401).json({ success: false, message: 'Unauthorized: Please log in.' });
    }

    const { id: orderId } = req.params;
    const { productId: orderedProductId } = req.body;
    if (!mongoose.Types.ObjectId.isValid(orderId) || !mongoose.Types.ObjectId.isValid(orderedProductId)) {
      return res.status(400).json({ success: false, message: 'Invalid order or product ID.' });
    }

    const user = await User.findById(userId);
    const order = await Order.findOne({ _id: orderId }).populate('orderedItems.product');
    if (!order || !user.orderHistory.includes(order._id)) {
      return res.status(404).json({ success: false, message: 'Order not found or unauthorized.' });
    }

    if (order.status.toLowerCase() === 'canceled' || order.status.toLowerCase() === 'delivered') {
      return res.status(400).json({ success: false, message: 'Order cannot be modified.' });
    }

    const itemIndex = order.orderedItems.findIndex(item => item._id.equals(orderedProductId));
    if (itemIndex === -1) {
      return res.status(404).json({ success: false, message: 'Product not found in order.' });
    }

    const item = order.orderedItems[itemIndex];
    if (item.quantity === 0) {
      return res.status(400).json({ success: false, message: 'Product is already canceled.' });
    }

    const subtotal = item.quantity * item.price;

    const product = await Product.findById(item.product);
    if (product) {
      product.quantity += item.quantity;
      await product.save();
    }

    // Mark product as canceled by setting quantity to 0
    order.orderedItems[itemIndex].quantity = 0;
    order.totalPrice -= subtotal;
    order.finalAmount -= subtotal;

    // Refund to wallet if payment was made
    if (subtotal > 0 && order.paymentMethod !== 'COD') {
      const wallet = await Wallet.findOneAndUpdate(
        { userId },
        {
          $inc: { balance: subtotal },
          $push: {
            transactions: {
              amount: subtotal,
              type: 'credit',
              description: `Refund for cancelled order ${order.orderId}`,
              date: new Date()
            }
          }
        },
        { upsert: true, new: true }
      );
    }

    // Check if all items are canceled
    const allCanceled = order.orderedItems.every(item => item.quantity === 0);
    if (allCanceled) {
      order.status = 'Canceled';
      order.totalPrice = 0;
      order.finalAmount = 0;
      order.discount = 0;
    }

    await order.save();

    res.status(200).json({ success: true, message: 'Product canceled successfully.' });
  } catch (error) {
    console.error('Error canceling product:', error.message, error.stack);
    res.status(500).json({ success: false, message: `Server error: ${error.message}` });
  }
};

const returnOrder = async (req, res) => {
  try {
    const userId = req.session.user;
    if (!userId) {
      return res.status(401).json({ success: false, message: 'Unauthorized: Please log in.' });
    }

    const { id } = req.params;
    const { reason } = req.body;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ success: false, message: 'Invalid order ID.' });
    }

    if (!reason || reason.trim() === '') {
      return res.status(400).json({ success: false, message: 'Return reason is required.' });
    }

    const user = await User.findById(userId);
    const order = await Order.findOne({ _id: id }).populate('orderedItems.product');
    if (!order || !user.orderHistory.includes(order._id)) {
      return res.status(404).json({ success: false, message: 'Order not found or unauthorized.' });
    }

    if (order.status.toLowerCase() !== 'delivered') {
      return res.status(400).json({ success: false, message: 'Only delivered orders can be returned.' });
    }

    order.status = 'Return Request';
    order.returnReason = reason.trim();

    // Add pending transaction for return refund
    await Wallet.findOneAndUpdate(
      { userId },
      {
        $push: {
          transactions: {
            amount: order.finalAmount,
            type: 'credit',
            description: `Pending refund for return of order ${order.orderId}`,
            date: new Date()
          }
        }
      },
      { upsert: true }
    );

    await order.save();

    res.status(200).json({ success: true, message: 'Return request submitted successfully.' });
  } catch (error) {
    console.error('Error submitting return request:', error.message, error.stack);
    res.status(500).json({ success: false, message: `Server error: ${error.message}` });
  }
};

const returnProduct = async (req, res) => {
  try {
    const userId = req.session.user;
    if (!userId) {
      return res.status(401).json({ success: false, message: 'Unauthorized: Please log in.' });
    }

    const { id: orderId } = req.params;
    const { productId: orderedProductId, reason } = req.body;
    if (!mongoose.Types.ObjectId.isValid(orderId) || !mongoose.Types.ObjectId.isValid(orderedProductId)) {
      return res.status(400).json({ success: false, message: 'Invalid order or product ID.' });
    }

    if (!reason || reason.trim() === '') {
      return res.status(400).json({ success: false, message: 'Return reason is required.' });
    }

    const user = await User.findById(userId);
    const order = await Order.findOne({ _id: orderId }).populate('orderedItems.product');
    if (!order || !user.orderHistory.includes(order._id)) {
      return res.status(404).json({ success: false, message: 'Order not found or unauthorized.' });
    }

    if (order.status.toLowerCase() !== 'delivered') {
      return res.status(400).json({ success: false, message: 'Only delivered orders can be returned.' });
    }

    const itemIndex = order.orderedItems.findIndex(item => item._id.equals(orderedProductId));
    if (itemIndex === -1) {
      return res.status(404).json({ success: false, message: 'Product not found in order.' });
    }

    const item = order.orderedItems[itemIndex];
    if (item.quantity === 0) {
      return res.status(400).json({ success: false, message: 'Canceled products cannot be returned.' });
    }

    const subtotal = item.quantity * item.price;

    // Add pending transaction for return refund
    await Wallet.findOneAndUpdate(
      { userId },
      {
        $push: {
          transactions: {
            amount: subtotal,
            type: 'credit',
            description: `Pending refund for return of product in order ${order.orderId}`,
            date: new Date()
          }
        }
      },
      { upsert: true }
    );

    // Store return reason in a metadata array since schema can't be modified
    if (!order.returnReasons) {
      order.returnReasons = [];
    }
    order.returnReasons.push({
      productId: orderedProductId,
      reason: reason.trim()
    });

    await order.save();

    res.status(200).json({ success: true, message: 'Product return request submitted successfully.' });
  } catch (error) {
    console.error('Error submitting product return request:', error.message, error.stack);
    res.status(500).json({ success: false, message: `Server error: ${error.message}` });
  }
};

// Other existing functions (getWallet, etc.) remain unchanged

module.exports = {
  getOBjofId,
  getOrderList,
  orderDetail,
  cancelOrder,
  cancelProduct,
  returnOrder,
  returnProduct,
  // Other exported functions
};